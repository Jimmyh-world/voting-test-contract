---
alwaysApply: true
---

# Solidity Development Cursor Rules

This guide is a comprehensive playbook for writing high-quality, secure, and gas-efficient Solidity code, optimized for collaboration with AI assistants. It provides explicit, enforceable rules and prompts to ensure consistent, reliable smart contract development.

## 0) Global Defaults - Design Integration

Apply these rules to every file and contract.

**Design Document Validation** (Must check before any implementation):

- **Design Summary**: Verify `docs/DESIGN_SUMMARY.md` exists and review it first
- **Scope Alignment**: Ensure implementation matches purpose and constraints from design docs
- **Security Requirements**: Cross-reference `docs/design/security-analysis.md` for security level
- **Interface Compliance**: Implement exactly what's specified in `docs/architecture/contract-interfaces.md`

**Standard Requirements**:

- **SPDX License**: `// SPDX-License-Identifier: MIT`
- **Pragma**: Pin exact version: `pragma solidity 0.8.24;` (or 0.8.25+ for newer features like transient storage). Avoid `^`.
- **Single Purpose**: One contract = one responsibility. Follow Separation of Concerns (SOC).
- **Constants**: Prefer `immutable` or `constant` for configuration variables.
- **Events**: Emit events for every state-changing operation with up to 3 indexed parameters.
- **Access & Validation**: All external entry points must have access control, input validation, and NatSpec documentation.

## 1) File & Project Structure

```
contracts/
├── access/         # Access control contracts
├── lib/           # Pure helper libraries
├── utils/         # Utility contracts
├── core/          # Main business logic
├── interfaces/    # Contract interfaces
├── proxy/         # Proxy contracts (if needed)
scripts/           # Deployment & management scripts
test/             # Comprehensive test suites
docs/             # Technical documentation
```

**Key Principles**:

- Define interfaces for all external contract surfaces
- Use libraries for pure functions that don't modify state
- Avoid "god contracts" - prefer multiple small, focused contracts
- Group related functionality in subdirectories

## 2) Enhanced Contract Skeleton

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/// @title <ContractTitle>
/// @notice <1-line plain-English purpose for end users>
/// @dev <key invariants, assumptions, links to specs/audits>
/// @dev Storage layout (for upgrade compatibility if applicable):
/// @dev   Slot 0: owner (address, immutable)
/// @dev   Slot 1: _counter (uint256)
interface IMyContract {
    /// @notice External interface definition
    function createThing() external returns (uint256 id);
}

/// @notice Thrown when caller is not the owner
error NotOwner();
/// @notice Thrown when invalid parameter provided
/// @param reason Specific reason for invalidity
error InvalidParam(bytes32 reason);
/// @notice Thrown when zero address provided where not allowed
error ZeroAddress();
/// @notice Thrown when insufficient balance for operation
/// @param available Current balance available
/// @param required Amount required for operation
error InsufficientBalance(uint256 available, uint256 required);
/// @notice Thrown when deadline has expired
/// @param deadline The expired deadline
/// @param current Current timestamp
error DeadlineExpired(uint256 deadline, uint256 current);

contract MyContract is IMyContract {
    // === Constants ===
    uint256 public constant MAX_FEE_BPS = 1_000; // 10%
    uint256 public constant MIN_DELAY = 1 days;

    // === Events ===
    /// @notice Emitted when a new thing is created
    /// @param creator Address that created the thing
    /// @param id Unique identifier of the created thing
    /// @param timestamp When the thing was created
    event ThingCreated(address indexed creator, uint256 indexed id, uint256 timestamp);

    /// @notice Emitted upon contract deployment
    /// @param owner Initial owner address
    /// @param version Contract version
    event Deployed(address indexed owner, string version);

    // === Storage ===
    address public immutable owner;
    uint256 private _counter; // Private: document why storage is needed
    mapping(address => uint256) private _balances;

    // === Constructor ===
    /// @notice Initialize the contract
    /// @param _owner Initial owner address
    constructor(address _owner) {
        if (_owner == address(0)) revert ZeroAddress();
        owner = _owner;

        emit Deployed(_owner, "1.0.0");
    }

    // === Modifiers ===
    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    modifier validAddress(address _addr) {
        if (_addr == address(0)) revert ZeroAddress();
        _;
    }

    modifier notExpired(uint256 _deadline) {
        if (block.timestamp > _deadline) revert DeadlineExpired(_deadline, block.timestamp);
        _;
    }

    // === External/Public Functions ===
    /// @notice Creates a new thing and emits an event
    /// @return id The unique identifier of the created thing
    function createThing() external override returns (uint256 id) {
        // Checks
        // (Add validation logic here)

        // Effects
        id = ++_counter;

        // Interactions (external calls go last)
        emit ThingCreated(msg.sender, id, block.timestamp);
    }

    /// @notice View the current counter value
    /// @return Current counter value
    function count() external view returns (uint256) {
        return _counter;
    }

    // === Internal/Private Functions ===
    /// @dev Internal helper functions go here
    /// @dev Keep them small, focused, and well-documented
    function _validateInput(uint256 _value) internal pure returns (bool) {
        return _value > 0 && _value <= MAX_FEE_BPS;
    }
}
```

## 3) Security Patterns & Best Practices

### Critical Security Rules

**CEI Pattern (Checks-Effects-Interactions)**: Apply to every state-changing function

1. **Checks**: Input validation, access control, business logic checks
2. **Effects**: Update state variables, emit events
3. **Interactions**: External calls, ETH transfers

**Time-Based Security**:

- Never rely solely on `block.timestamp` for critical logic
- Use time delays for sensitive operations
- Be aware of MEV and block timestamp manipulation (±15 seconds)

**Access Control Patterns**:

```solidity
// Prefer role-based access over boolean flags
import "@openzeppelin/contracts/access/AccessControl.sol";

// For simple cases, use explicit checks
modifier onlyAuthorized(bytes32 role) {
    if (!hasRole(role, msg.sender)) revert Unauthorized(role, msg.sender);
    _;
}
```

**Reentrancy Protection**:

- Follow CEI pattern rigorously
- Use OpenZeppelin's ReentrancyGuard only when external calls are unavoidable
- Prefer pull over push patterns for ETH/token transfers

**Oracle & Flash Loan Protection**:

```solidity
// Use TWAP or multiple oracle sources
// Implement price deviation checks
// Add flash loan detection mechanisms
modifier noFlashLoan() {
    require(tx.origin == msg.sender, "Flash loan detected");
    _;
}
```

### Input Validation & Error Handling

**Custom Errors with Parameters**:

```solidity
error InsufficientAllowance(address owner, address spender, uint256 requested, uint256 available);
error InvalidSignature(address signer, bytes32 hash);
error SlippageExceeded(uint256 expected, uint256 actual, uint256 tolerance);
```

**Signature Replay Prevention**:

```solidity
mapping(address => uint256) public nonces;

function executeWithSignature(
    bytes calldata signature,
    uint256 nonce,
    uint256 deadline
) external notExpired(deadline) {
    if (nonces[msg.sender] != nonce) revert InvalidNonce(nonces[msg.sender], nonce);
    nonces[msg.sender]++;
    // ... signature verification logic
}
```

## 4) Gas Optimization Guidelines

### Storage Optimization

```solidity
// Pack structs efficiently (32-byte boundaries)
struct PackedData {
    uint128 amount;     // 16 bytes
    uint64 timestamp;   // 8 bytes
    uint32 category;    // 4 bytes
    bool isActive;      // 1 byte
    // Total: 29 bytes (fits in 32-byte slot)
}

// Use appropriate sized integers
uint64 public constant SECONDS_PER_YEAR = 365 days; // Instead of uint256
```

### Function Optimization

```solidity
// Use calldata for external function parameters
function batchProcess(uint256[] calldata ids, bytes calldata data) external {
    // Avoid copying to memory unless necessary
}

// Cache storage reads
function complexCalculation() external view returns (uint256) {
    uint256 cachedCounter = _counter; // Single SLOAD
    return cachedCounter * cachedCounter + cachedCounter;
}

// Use unchecked for safe arithmetic (Solidity 0.8.0+)
function safeIncrement(uint256 value) internal pure returns (uint256) {
    unchecked {
        return value + 1; // Safe when you know it won't overflow
    }
}
```

### Event Optimization

```solidity
// Use up to 3 indexed parameters for optimal filtering
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);

// Use events for historical data instead of storage
event StateChange(uint256 indexed blockNumber, bytes32 indexed stateHash, bytes data);
```

## 5) Testing Requirements

### Coverage Standards

- **100% line coverage** for all external/public functions
- **Branch coverage** for all conditional logic
- **Edge case testing** (zero values, max values, boundary conditions)
- **Invariant testing** for critical system properties

### Testing Patterns

```solidity
// AAA Pattern (Arrange, Act, Assert)
function testCreateThing() public {
    // Arrange
    address creator = makeAddr("creator");
    vm.prank(creator);

    // Act
    uint256 id = contract.createThing();

    // Assert
    assertEq(id, 1);
    assertEq(contract.count(), 1);
}

// Fuzz testing for all user inputs
function testFuzzCreateThingWithValue(uint256 value) public {
    vm.assume(value > 0 && value <= MAX_VALUE);
    // Test with random valid inputs
}

// Invariant testing
function invariant_TotalSupplyEqualsIndividualBalances() public {
    // Critical system properties that should never break
}
```

### Integration Testing

```solidity
// Fork testing for mainnet interactions
function testMainnetIntegration() public {
    vm.createFork(MAINNET_RPC_URL, BLOCK_NUMBER);
    // Test against real mainnet state
}

// Gas benchmarking
function testGasConsumption() public {
    uint256 gasStart = gasleft();
    contract.expensiveFunction();
    uint256 gasUsed = gasStart - gasleft();
    assertLt(gasUsed, MAX_GAS_LIMIT);
}
```

## 6) Documentation Standards

### NatSpec Requirements

```solidity
/// @title Clear, descriptive title
/// @notice Plain English explanation for end users
/// @dev Technical details, assumptions, and invariants
/// @param paramName Description of parameter and constraints
/// @return returnName Description of return value and format
/// @custom:security-contact security@example.com
/// @custom:audit-report https://example.com/audit-report.pdf
contract ExampleContract {
    /// @notice Transfers tokens from sender to recipient
    /// @dev Implements ERC20 transfer with additional checks
    /// @param to Recipient address (cannot be zero address)
    /// @param amount Token amount to transfer (must be > 0 and <= balance)
    /// @return success True if transfer succeeded
    function transfer(address to, uint256 amount) external returns (bool success);
}
```

### Code Comments

```solidity
// Comment WHY, not WHAT
// Good: Delay required to prevent flash loan attacks
uint256 public constant TRANSFER_DELAY = 1 hours;

// Bad: Set delay to 1 hour
uint256 public constant TRANSFER_DELAY = 1 hours;
```

## 7) Common Pitfalls (Avoid These)

- ❌ **Never use `tx.origin`** - always use `msg.sender`
- ❌ **No unbounded loops** - especially over user-controlled arrays
- ❌ **Don't store large dynamic data on-chain** - use events or IPFS
- ❌ **Avoid floating-point arithmetic** - use fixed-point math libraries
- ❌ **No raw ETH acceptance without withdrawal mechanism**
- ❌ **Don't ignore return values** from external calls
- ❌ **Avoid block hash dependencies** beyond recent blocks
- ❌ **No hardcoded gas limits** in external calls

## 8) Deployment & Security Checklist

### Pre-Deployment Verification

- ✅ SPDX license and exact pragma present
- ✅ No unused state variables or dead code
- ✅ All state changes emit appropriate events
- ✅ Access control on all state-changing external functions
- ✅ CEI pattern followed, no reentrancy risks
- ✅ No unbounded loops or DoS vectors
- ✅ Custom errors used consistently
- ✅ Gas optimizations applied (calldata, packing, caching)
- ✅ Comprehensive test coverage (success + revert paths)
- ✅ NatSpec documentation on all external functions
- ✅ Static analysis tools run (Slither, Mythril)
- ✅ Formal verification for critical components
- ✅ External audit completed (for high-value contracts)

### Deployment Best Practices

```solidity
contract DeploymentContract {
    /// @notice Emitted upon successful deployment
    event ContractDeployed(
        address indexed contractAddress,
        address indexed deployer,
        string version,
        bytes32 configHash
    );

    constructor(
        address _owner,
        uint256 _initialValue,
        bytes32 _configHash
    ) {
        // Validate all constructor parameters
        require(_owner != address(0), "Invalid owner");
        require(_initialValue > 0, "Invalid initial value");

        // Emit deployment event with key parameters
        emit ContractDeployed(address(this), msg.sender, "1.0.0", _configHash);
    }
}
```

## 9) Enhanced AI Collaboration Prompts

### A. Design-Driven Contract Implementation

```
You are implementing a smart contract with existing design documentation. Before writing any code:

1. **Design Document Review**:
   - Read and summarize docs/DESIGN_SUMMARY.md
   - Confirm implementation scope matches technical specification
   - Verify security requirements from docs/design/security-analysis.md
   - Check interface matches docs/architecture/contract-interfaces.md exactly
   - Ensure state management follows docs/architecture/state-management.md

2. **Implementation Requirements**:
   - Use SPDX MIT license and pragma 0.8.24+
   - Implement exactly the functions specified in design documents
   - Follow CEI pattern and include comprehensive custom errors
   - Apply access control model from docs/design/architecture-decisions.md
   - Implement threat mitigations from docs/architecture/threat-model.md
   - Include NatSpec documentation matching design specifications

3. **Validation**:
   - Cross-reference every function against interface specification
   - Ensure all security requirements are addressed
   - Verify state variables match state management design
   - Confirm gas optimization strategies are applied

If any design document is missing or unclear, request clarification before proceeding.
```

### B. Design-Compliance Security Review

```
Perform a comprehensive security review using design documents as requirements:

1. **Threat Model Validation**:
   - Review docs/architecture/threat-model.md
   - Verify each identified threat has corresponding mitigation in code
   - Check that all external dependencies have proper fallback mechanisms
   - Validate oracle manipulation and flash loan protections

2. **Access Control Verification**:
   - Ensure implementation matches access control design in docs/design/architecture-decisions.md
   - Verify admin functions are minimal and properly protected
   - Check that permission transfer mechanisms work as designed
   - Validate immutable elements cannot be changed

3. **State Invariant Testing**:
   - Verify all invariants from docs/architecture/state-management.md are maintained
   - Check that state transitions follow designed patterns
   - Ensure no state can be corrupted through any execution path

4. **Interface Security**:
   - Confirm all functions in docs/architecture/contract-interfaces.md have proper validation
   - Verify input sanitization and error handling
   - Check gas limit considerations and DoS prevention

Provide a detailed compliance report showing how each design requirement is implemented, with specific code references.
```

### C. Design-Driven Test Generation

```
Generate comprehensive Foundry tests based on design documentation:

1. **Design Document Analysis**:
   - Review docs/architecture/contract-interfaces.md for all functions to test
   - Use docs/design/security-analysis.md to identify high-risk scenarios
   - Reference docs/architecture/threat-model.md for attack vector testing
   - Check docs/design/implementation-roadmap.md for testing requirements

2. **Test Suite Structure**:
   **Unit Tests** (for each function in interface specification):
   - Happy path scenarios with expected inputs/outputs
   - Edge cases (zero values, maximum values, boundary conditions)
   - Access control enforcement testing
   - Custom error validation for all revert conditions
   - Event emission verification

   **Security Tests** (based on threat model):
   - Reentrancy attack simulations
   - Access control bypass attempts
   - Front-running and MEV vulnerability tests
   - Oracle manipulation scenarios
   - Flash loan attack vectors
   - Gas limit DoS attempts

   **Integration Tests** (for external dependencies):
   - External contract failure scenarios
   - Oracle failure and fallback testing
   - Multi-contract interaction flows
   - Upgrade compatibility testing (if applicable)

3. **Test Organization**:
   - Follow AAA pattern (Arrange, Act, Assert)
   - Use descriptive test names explaining the scenario
   - Include gas consumption benchmarks
   - Add invariant testing for critical system properties
   - Implement fuzz testing for all user inputs

Provide complete test files with setup, helper functions, and execution instructions.
```

### D. Advanced Security Audit

```
Act as a security auditor with access to design documentation. Perform analysis using:

**Design Context** (review first):
- docs/design/security-analysis.md for asset risks and value at stake
- docs/architecture/threat-model.md for known threats and mitigations
- docs/design/architecture-decisions.md for access control requirements

**Vulnerability Assessment**:
1. **High-Priority Vectors** (based on design security level):
   - Reentrancy and CEI pattern violations
   - Access control flaws and privilege escalation
   - Integer overflow/underflow in arithmetic operations
   - Front-running and transaction ordering dependencies
   - Oracle manipulation and price feed attacks
   - Flash loan attack possibilities
   - Gas limit DoS and griefing attacks
   - Time-based manipulation (block.timestamp dependencies)

2. **Design-Specific Risks**:
   - Verify mitigations for threats identified in threat model
   - Check admin functions against architecture decisions
   - Validate external dependency handling
   - Assess upgrade safety (if applicable)

**Output Format**:
For each vulnerability found:
- **Design Reference**: Which document(s) address this risk
- **Severity**: Critical/High/Medium/Low with CVSS-like scoring
- **Attack Vector**: Concrete exploitation example
- **Code Location**: Exact lines/functions affected
- **Mitigation**: Specific code diff to fix
- **Prevention**: Design patterns to avoid similar issues

Include a final compliance statement: "Implementation matches/deviates from design security requirements in [specific areas]."
```

### E. Comprehensive Documentation Generation

```
Generate comprehensive documentation that aligns with design specifications:

**Design Document Integration**:
- Reference docs/design/technical-specification.md for contract purpose and scope
- Use docs/architecture/contract-interfaces.md for function descriptions
- Include security context from docs/design/security-analysis.md
- Cross-reference architecture decisions for access control explanations

**Documentation Structure**:

1. **Contract Overview**:
   - Purpose statement from technical specification
   - User types and use cases from design documents
   - Security model and trust assumptions
   - Integration points and external dependencies

2. **Function Documentation** (comprehensive NatSpec):
   - All external/public functions with complete @param and @return tags
   - Include @dev tags explaining design decisions
   - Reference specific sections of design documents where relevant
   - Document security considerations for each function

3. **Developer Guide**:
   - Architecture overview referencing design documents
   - State management explanation from state-management.md
   - Security considerations from threat model
   - Gas optimization strategies applied
   - Deployment and configuration instructions

4. **User Guide**:
   - Step-by-step interaction examples
   - Common use cases from technical specification
   - Error handling and troubleshooting
   - Integration examples for dApp developers

5. **Cross-Reference Index**:
   - Map each code section to relevant design document
   - Link functions to their specification in contract-interfaces.md
   - Reference security mitigations to threat-model.md entries

Format as professional markdown with proper navigation and linking between design documents and implementation.
```

### F. Complete Deployment Package

```
Create a complete deployment package based on design documentation:

**Design Requirements Analysis**:
- Review docs/design/implementation-roadmap.md for deployment strategy
- Check docs/design/architecture-decisions.md for constructor requirements
- Reference docs/design/security-analysis.md for security deployment considerations
- Use docs/architecture/contract-interfaces.md for verification requirements

**Deployment Package Components**:

1. **Deployment Scripts**:
   - Constructor parameter validation based on architecture decisions
   - Multi-network deployment configuration
   - Post-deployment verification against interface specifications
   - Integration with existing contract ecosystem

2. **Verification & Testing**:
   - Automated verification that deployed contract matches design
   - Integration tests against live contracts
   - Security validation checklist from threat model
   - Gas cost verification against optimization targets

3. **Configuration Management**:
   - Environment-specific parameter files
   - Admin setup procedures from architecture decisions
   - Emergency procedures and circuit breakers
   - Monitoring and alerting setup

4. **Operations Documentation**:
   - Deployment runbook with step-by-step procedures
   - Post-deployment configuration checklist
   - Emergency response procedures
   - Regular maintenance and monitoring tasks

5. **Governance Setup** (if applicable):
   - Multi-signature wallet configuration
   - Admin role assignment procedures
   - Upgrade procedures and governance workflows
   - Key management and rotation policies

Include all necessary scripts, configuration files, and detailed procedures for production deployment.
```

### G. Implementation Validation Against Design

```
Validate that the current implementation fully complies with design specifications:

**Compliance Checklist**:

1. **Functional Compliance**:
   - [ ] All functions from docs/architecture/contract-interfaces.md are implemented
   - [ ] Function signatures match interface specifications exactly
   - [ ] Return values and events match design requirements
   - [ ] No additional functions beyond design scope

2. **Security Compliance**:
   - [ ] All threats from docs/architecture/threat-model.md are mitigated
   - [ ] Access control matches docs/design/architecture-decisions.md
   - [ ] Asset handling follows docs/design/security-analysis.md requirements
   - [ ] No new attack vectors introduced

3. **Architecture Compliance**:
   - [ ] State variables match docs/architecture/state-management.md design
   - [ ] External dependencies handled as specified in threat model
   - [ ] Gas optimization targets from design documents are met
   - [ ] Contract structure follows single responsibility principle

4. **Documentation Compliance**:
   - [ ] All NatSpec matches design specifications
   - [ ] Security assumptions documented and match design
   - [ ] Integration guidance reflects design decisions
   - [ ] Emergency procedures documented

**Deviation Analysis**:
For any compliance failures:
- Identify specific design requirement that's not met
- Explain why deviation occurred
- Assess security and functionality impact
- Provide remediation options (code fix vs. design update)

**Final Validation**:
Generate a compliance report showing percentage adherence to design specifications and recommend next steps for any deviations.
```

## 10) Advanced Patterns & Considerations

### Proxy Patterns (Use Sparingly)

```solidity
// Only when upgradeability is absolutely necessary
// Document storage layout extensively
// Use initialization functions instead of constructors
// Implement proper access controls for upgrades

contract Implementation {
    /// @custom:storage-location erc7201:example.storage.Counter
    struct CounterStorage {
        uint256 value;
        mapping(address => bool) authorized;
    }

    // keccak256(abi.encode(uint256(keccak256("example.storage.Counter")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant CounterStorageLocation = 0x...;

    function _getCounterStorage() private pure returns (CounterStorage storage $) {
        assembly {
            $.slot := CounterStorageLocation
        }
    }
}
```

### Assembly Usage (Minimal & Safe)

```solidity
// Only use assembly when absolutely necessary for gas optimization
// Always document thoroughly and add safety checks
function efficientHash(bytes32 a, bytes32 b) internal pure returns (bytes32 result) {
    /// @dev Using assembly for gas-efficient hashing
    assembly {
        mstore(0x00, a)
        mstore(0x20, b)
        result := keccak256(0x00, 0x40)
    }
}
```

## Final Principles - Design-Driven Development

**Design-First Approach**: No code should be written without corresponding design documentation in `docs/design/` and `docs/architecture/`.

**Cross-Reference Validation**: Every implementation decision must be traceable to a design document.

**KISS Compliance**: Both design and implementation must pass simplicity tests - if you can't explain it simply, it's too complex.

**Security by Design**: Security measures should be specified in design phase and validated during implementation.

**Documentation Synchronization**: Keep design documents and implementation in sync - update design docs if implementation requirements change.

**Quality Gates**: Use design documents as acceptance criteria - implementation is complete only when it fully satisfies design specifications.

---

## Design-Development Integration Checklist

Before starting any contract implementation:

- ✅ `docs/DESIGN_SUMMARY.md` exists and has been reviewed
- ✅ All design documents in `docs/design/` are complete
- ✅ All architecture documents in `docs/architecture/` are complete
- ✅ Design has passed KISS compliance review
- ✅ Security requirements are clearly specified
- ✅ Interface specifications are detailed and minimal

During implementation:

- ✅ Each function maps to design specification
- ✅ Security mitigations match threat model
- ✅ State management follows architecture design
- ✅ Access control implements architecture decisions
- ✅ Gas optimizations align with design targets

After implementation:

- ✅ All design requirements are satisfied
- ✅ No new attack vectors introduced
- ✅ Documentation reflects both design and implementation
- ✅ Tests validate design requirements
- ✅ Deployment follows design roadmap

---

_This integrated cursor rules file ensures seamless collaboration between design and development phases, maintaining KISS principles while producing secure, efficient smart contracts that exactly match their specifications._
