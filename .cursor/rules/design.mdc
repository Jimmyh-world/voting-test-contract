---
description: This guide integrates with Cursor IDE to manage the complete smart contract design-to-development workflow. It produces structured documentation that your Solidity cursor rules can cross-reference during implementation.
alwaysApply: false
---

# Cursor-Integrated Smart Contract Design Guide

This guide integrates with Cursor IDE to manage the complete smart contract design-to-development workflow. It produces structured documentation that your Solidity cursor rules can cross-reference during implementation.

## Project Structure Setup

**Cursor AI Instructions**: Before starting design, create this folder structure:

```
project/
├── contracts/              # Smart contract source code
├── docs/
│   ├── design/            # Design phase outputs
│   │   ├── technical-specification.md
│   │   ├── security-analysis.md
│   │   ├── architecture-decisions.md
│   │   └── implementation-roadmap.md
│   └── architecture/      # Architecture documentation
│       ├── contract-interfaces.md
│       ├── state-management.md
│       ├── threat-model.md
│       └── gas-optimization.md
├── scripts/               # Deployment scripts
└── test/                 # Test files
```

**Cursor Command**: Use this to auto-generate the structure:

```bash
mkdir -p docs/design docs/architecture contracts scripts test
touch docs/design/{technical-specification,security-analysis,architecture-decisions,implementation-roadmap}.md
touch docs/architecture/{contract-interfaces,state-management,threat-model,gas-optimization}.md
```

## Phase 1: Discovery Questions

**Cursor AI Instructions**: Ask these questions and save responses directly to design documents. Reference the KISS principle after every answer - push back on complexity.

### A. Core Purpose & Scope

**File**: `docs/design/technical-specification.md`

**Ask the designer:**

1. **What is the ONE primary problem this contract solves?** (Force a single sentence answer)

2. **Who are the main users/actors?** (List max 3-5 distinct user types)

3. **What should this contract NOT do?** (Define boundaries clearly)

4. **What's the simplest version that would still be useful?** (MVP thinking)

5. **Are there any existing contracts or standards this should be compatible with?** (ERC-20, ERC-721, etc.)

**KISS Check**: If the answer to question 1 requires multiple sentences or uses "and" more than once, the scope is too broad. Push for simplification.

**Cursor Action**: After getting answers, immediately update `docs/design/technical-specification.md` with this template:

```markdown
# Technical Specification: [Contract Name]

## Core Purpose

**Problem Statement**: [Single sentence from Q1]
**Target Users**: [List from Q2]
**Scope Boundaries**: [What it does NOT do from Q3]
**MVP Definition**: [Simplest useful version from Q4]
**Standards Compatibility**: [Any ERC standards from Q5]

## KISS Validation

- [ ] Purpose fits in one sentence
- [ ] User types ≤ 5
- [ ] Clear boundaries defined
- [ ] MVP identified
- Date: [Current Date]
- Reviewed by: [Designer Name]
```

### B. Value & Assets

**File**: `docs/design/security-analysis.md`

**Ask the designer:**

1. **Does this contract handle valuable assets?** (ETH, ERC-20 tokens, NFTs, etc.)

2. **What's the maximum value this contract might hold at any time?** (Helps determine security requirements)

3. **Who should be able to withdraw/transfer these assets?** (Clear ownership rules)

4. **Should there be any limits on withdrawals/transfers?** (Rate limiting, minimum amounts, etc.)

5. **What happens to assets if something goes wrong?** (Emergency procedures)

**Cursor Action**: Update `docs/design/security-analysis.md`:

```markdown
# Security Analysis: [Contract Name]

## Asset Management

**Asset Types**: [From Q1]
**Maximum Value at Risk**: [From Q2]
**Withdrawal Permissions**: [From Q3]
**Transfer Limits**: [From Q4]
**Emergency Procedures**: [From Q5]

## Risk Assessment

- **Value at Risk**: [High/Medium/Low]
- **Security Requirements**: [Based on max value]
- **Emergency Controls Needed**: [Yes/No with details]
```

### C. User Interactions

**File**: `docs/architecture/contract-interfaces.md`

**Ask the designer:**

1. **What are the 3-5 most important functions users will call?** (Core user journeys)

2. **Should any functions cost gas for users vs. be sponsored?** (UX considerations)

3. **What information do users need to see?** (Read-only functions)

4. **Should users be able to batch multiple operations?** (Gas efficiency)

5. **What should happen if a user makes a mistake?** (Reversibility, safeguards)

**Cursor Action**: Create interface definitions in `docs/architecture/contract-interfaces.md`:

```markdown
# Contract Interfaces: [Contract Name]

## Core User Functions

1. **[Function1]**: [Purpose and basic signature]
2. **[Function2]**: [Purpose and basic signature]
3. **[Function3]**: [Purpose and basic signature]

## View Functions

- **[ViewFunction1]**: [What data it returns]
- **[ViewFunction2]**: [What data it returns]

## Gas Considerations

**User-Paid Functions**: [List]
**Sponsored Functions**: [List if any]
**Batch Operations**: [Supported/Not supported]

## Error Handling

**Mistake Prevention**: [Safeguards]
**Reversibility**: [What can/cannot be undone]

## Interface Validation

- [ ] External functions ≤ 7
- [ ] Clear user journeys defined
- [ ] Gas costs considered
```

### D. Access Control & Permissions

**File**: `docs/design/architecture-decisions.md`

**Ask the designer:**

1. **Who should have administrative control?** (Owner, DAO, multisig, etc.)

2. **What admin functions are absolutely necessary?** (Pause, upgrade, parameter changes)

3. **Should there be different permission levels?** (Roles beyond just owner/user)

4. **How should admin permissions be transferred or revoked?** (Governance process)

5. **What should be immutable once deployed?** (Things that should never change)

**Cursor Action**: Document access control in `docs/design/architecture-decisions.md`:

```markdown
# Architecture Decisions: [Contract Name]

## Access Control Design

**Admin Authority**: [From Q1]
**Required Admin Functions**: [From Q2]
**Permission Levels**: [From Q3]
**Permission Transfer Process**: [From Q4]
**Immutable Elements**: [From Q5]

## Decision Rationale

**Why this access model**: [Explanation]
**Alternatives considered**: [Other options and why rejected]
**Security implications**: [How this affects security]

## Admin Function Justification

| Function   | Necessity             | Risk Level   | Mitigation        |
| ---------- | --------------------- | ------------ | ----------------- |
| [Function] | Critical/Nice-to-have | High/Med/Low | [How to mitigate] |
```

### E. External Dependencies

**File**: `docs/architecture/threat-model.md`

**Ask the designer:**

1. **Does this contract need to interact with other contracts?** (DEXs, oracles, registries)

2. **What happens if those external contracts fail or are compromised?** (Fallback plans)

3. **Do you need price feeds or external data?** (Oracle requirements)

4. **Should this contract be upgradeable?** (Almost always answer should be NO)

5. **Are there any governance or voting requirements?** (DAO integration)

**Cursor Action**: Create threat model in `docs/architecture/threat-model.md`:

```markdown
# Threat Model: [Contract Name]

## External Dependencies

| Dependency        | Purpose   | Failure Impact | Mitigation Strategy |
| ----------------- | --------- | -------------- | ------------------- |
| [Contract/Oracle] | [Purpose] | [What breaks]  | [Fallback plan]     |

## Upgradeability Decision

**Upgradeable**: [Yes/No]
**Rationale**: [Why this decision was made]
**If Yes - Risks**: [Upgrade-related risks]
**If No - Limitations**: [What can't be changed]

## Trust Assumptions

**Users must trust**: [List entities]
**Single points of failure**: [Critical dependencies]
**Governance requirements**: [Any DAO integration needs]

## Dependency Risk Assessment

- **High Risk**: [Dependencies that could break everything]
- **Medium Risk**: [Dependencies with fallbacks]
- **Low Risk**: [Nice-to-have dependencies]
```

### F. Economic Model

**File**: `docs/design/technical-specification.md` (append section)

**Ask the designer:**

1. **How does this contract make money or create value?** (Business model)

2. **Are there any fees, and if so, who pays them?** (Revenue streams)

3. **What are the incentives for users to interact honestly?** (Game theory)

4. **What happens if the contract becomes unprofitable to maintain?** (Sustainability)

5. **Are there any token economics or rewards involved?** (Tokenomics)

**Cursor Action**: Append to `docs/design/technical-specification.md`:

```markdown
## Economic Model

**Value Creation**: [How it creates value]
**Fee Structure**: [Who pays what fees]
**User Incentives**: [Why users behave honestly]
**Sustainability Plan**: [Long-term viability]
**Token Economics**: [Any token-related mechanics]

## Economic Risks

**Fee optimization attacks**: [Potential gaming]
**Economic exploits**: [Value extraction risks]
**Sustainability concerns**: [Long-term viability issues]
```

---

## Phase 2: Collaborative Analysis & Documentation

**Cursor AI Instructions**: After discovery, use these prompts to refine the design and generate comprehensive documentation.

### A. KISS Simplification Review

**Files to Update**: All design files

**Cursor Prompt**:

```
Based on the discovery phase in docs/design/, perform a KISS simplification review:

1. **Function Reduction Analysis**:
   - Review docs/architecture/contract-interfaces.md
   - Identify the 3 most critical functions
   - Challenge each additional function: "Is this essential or nice-to-have?"
   - Update the interface doc with simplified function set

2. **Admin Function Challenge**:
   - Review docs/design/architecture-decisions.md
   - For each admin function, ask: "What's the worst that happens if we don't have this?"
   - Remove any admin functions that aren't absolutely critical
   - Update the decisions doc with final admin surface

3. **Dependency Minimization**:
   - Review docs/architecture/threat-model.md
   - For each external dependency: "Can we eliminate this or make it optional?"
   - Document fallback strategies for remaining dependencies
   - Update threat model with minimal dependency set

Create a KISS compliance report and save to docs/design/kiss-compliance.md
```

### B. Security Architecture Design

**File**: `docs/architecture/threat-model.md` (expand)

**Cursor Prompt**:

```
Based on all design documents, create a comprehensive security analysis:

1. **Attack Surface Mapping**:
   - List all external functions from docs/architecture/contract-interfaces.md
   - Identify potential attack vectors for each function
   - Cross-reference with asset information from docs/design/security-analysis.md

2. **Trust Model Analysis**:
   - Map all trust relationships from design documents
   - Identify what happens if each trusted party becomes malicious
   - Document trust minimization strategies

3. **Failure Mode Analysis**:
   - For each external dependency in threat-model.md
   - Define failure scenarios and their impact
   - Create mitigation strategies

Update docs/architecture/threat-model.md with comprehensive security architecture.
```

### C. State Management Architecture

**File**: `docs/architecture/state-management.md`

**Cursor Prompt**:

```
Design the state management architecture based on all discovery documents:

1. **Essential State Identification**:
   - From technical-specification.md, identify minimum required state
   - From contract-interfaces.md, determine what state each function needs
   - Eliminate redundant or derivable state

2. **State Relationship Mapping**:
   - Identify how different state variables relate
   - Check for circular dependencies
   - Define critical invariants that must always hold

3. **Gas Optimization Planning**:
   - Plan storage variable packing opportunities
   - Identify state that can be stored in events vs. storage
   - Document expensive operations and alternatives

Save comprehensive state architecture to docs/architecture/state-management.md
```

### D. Implementation Planning

**File**: `docs/design/implementation-roadmap.md`

**Cursor Prompt**:

```
Create a detailed implementation roadmap based on all design documents:

1. **MVP Definition** (from technical-specification.md):
   - List exactly which functions are in MVP
   - Define MVP success criteria
   - Estimate MVP complexity and timeline

2. **Phased Development Plan**:
   - Phase 1: Core MVP functionality
   - Phase 2: Enhanced features (if any)
   - Phase 3: Nice-to-have features (if any)

3. **Testing Strategy**:
   - Unit test requirements for each function
   - Integration test scenarios for external dependencies
   - Security test cases from threat model
   - Gas optimization test benchmarks

4. **Deployment Strategy**:
   - Constructor parameter requirements
   - Post-deployment verification steps
   - Emergency procedures and circuit breakers

Save complete implementation plan to docs/design/implementation-roadmap.md
```

---

## Phase 3: Cross-Reference Integration

**Cursor AI Instructions**: Create integration points between design documents and Solidity development.

### A. Design Summary for Development

**File**: `docs/DESIGN_SUMMARY.md`

**Cursor Prompt**:

```
Create a concise design summary that Solidity development can reference:

# Design Summary: [Contract Name]

## Quick Reference
- **Purpose**: [One sentence from technical-specification.md]
- **Key Functions**: [3-5 core functions from contract-interfaces.md]
- **Security Level**: [High/Medium/Low from security-analysis.md]
- **External Dependencies**: [List from threat-model.md]

## Implementation Constraints
- **Max External Functions**: [Number from interface design]
- **Required Events**: [From state-management.md]
- **Access Control**: [From architecture-decisions.md]
- **Gas Targets**: [From gas-optimization.md]

## Cross-References
- Full specification: `docs/design/technical-specification.md`
- Security requirements: `docs/design/security-analysis.md`
- Interface definitions: `docs/architecture/contract-interfaces.md`
- Threat model: `docs/architecture/threat-model.md`

## Development Checklist
- [ ] Implementation matches interface in contract-interfaces.md
- [ ] Security requirements from security-analysis.md are met
- [ ] Threat mitigations from threat-model.md are implemented
- [ ] State management follows state-management.md design
- [ ] Gas optimizations from gas-optimization.md are applied

This summary should be referenced during all development phases.
```

### B. Solidity Cursor Rules Integration

**Update your existing Solidity cursor rules** to include these design cross-reference prompts:

```markdown
## 0) Global Defaults - Design Integration

Before implementing any contract, AI must:

1. **Check Design Documents**: Verify that `docs/DESIGN_SUMMARY.md` exists and review it
2. **Validate Scope**: Ensure implementation matches the purpose and constraints in the design summary
3. **Security Alignment**: Cross-reference security requirements from `docs/design/security-analysis.md`
4. **Interface Compliance**: Implement exactly the functions specified in `docs/architecture/contract-interfaces.md`

## Enhanced AI Collaboration Prompts

### A. Implementation Validation
```

You are implementing a contract with existing design documentation. Before writing code:

1. Read and summarize docs/DESIGN_SUMMARY.md
2. Confirm the implementation scope matches the technical specification
3. Verify all security requirements from docs/design/security-analysis.md are addressed
4. Check that the interface matches docs/architecture/contract-interfaces.md exactly
5. Ensure state management follows docs/architecture/state-management.md
6. Validate that threat mitigations from docs/architecture/threat-model.md are included

If any design document is missing or unclear, stop and request clarification before proceeding.

```

### B. Design-Driven Security Review
```

Perform a security review using the design documents as requirements:

1. **Threat Model Compliance**: Check each threat in docs/architecture/threat-model.md has corresponding mitigation in code
2. **Access Control Verification**: Ensure implementation matches access control design in docs/design/architecture-decisions.md
3. **State Invariants**: Verify all invariants from docs/architecture/state-management.md are maintained
4. **Interface Security**: Confirm all functions in docs/architecture/contract-interfaces.md have proper validation

Provide a compliance report showing how each design requirement is implemented.

```

```

---

## Phase 4: Cursor Workflow Integration

### A. Design Phase Commands

**Cursor Terminal Commands** for design phase:

```bash
# Start new contract design
mkdir -p docs/design docs/architecture
touch docs/design/{technical-specification,security-analysis,architecture-decisions,implementation-roadmap}.md
touch docs/architecture/{contract-interfaces,state-management,threat-model,gas-optimization}.md

# Validate design completeness
ls docs/design/ docs/architecture/ | wc -l  # Should return 8

# Check design document status
find docs/ -name "*.md" -exec wc -l {} + | tail -1  # Total lines written
```

### B. Development Phase Commands

**Cursor Terminal Commands** for development phase:

```bash
# Verify design exists before coding
test -f docs/DESIGN_SUMMARY.md && echo "Design ready" || echo "Complete design phase first"

# Cross-reference during development
grep -r "function" docs/architecture/contract-interfaces.md  # Check required functions
grep -r "admin" docs/design/architecture-decisions.md       # Check admin requirements
grep -r "threat" docs/architecture/threat-model.md          # Check security requirements
```

### C. File Watching and Validation

**Cursor Settings** for automatic validation:

```json
{
  "files.watcherExclude": {
    "**/docs/**": false
  },
  "editor.formatOnSave": true,
  "files.associations": {
    "docs/**/*.md": "markdown"
  }
}
```

---

## Phase 5: Validation and Quality Gates

### A. Design Completeness Check

**Cursor Prompt**:

```
Perform a design completeness audit:

1. **Required Files Check**:
   - [ ] docs/design/technical-specification.md (>100 lines)
   - [ ] docs/design/security-analysis.md (>50 lines)
   - [ ] docs/design/architecture-decisions.md (>50 lines)
   - [ ] docs/design/implementation-roadmap.md (>50 lines)
   - [ ] docs/architecture/contract-interfaces.md (>30 lines)
   - [ ] docs/architecture/state-management.md (>30 lines)
   - [ ] docs/architecture/threat-model.md (>50 lines)
   - [ ] docs/DESIGN_SUMMARY.md (>30 lines)

2. **Content Quality Check**:
   - [ ] Purpose is single sentence
   - [ ] External functions ≤ 7
   - [ ] Admin functions minimized and justified
   - [ ] All external dependencies have fallback plans
   - [ ] Security threats identified and mitigated
   - [ ] State variables are minimal and justified

3. **Cross-Reference Validation**:
   - [ ] All functions in contract-interfaces.md are in technical-specification.md
   - [ ] All admin functions in architecture-decisions.md are security-justified
   - [ ] All external dependencies in threat-model.md have failure handling
   - [ ] Implementation roadmap covers all features in technical specification

If any check fails, provide specific remediation steps.
```

### B. KISS Compliance Final Review

**Cursor Prompt**:

```
Final KISS compliance review across all design documents:

**The 'Grandmother Test'**: Based on docs/design/technical-specification.md, could you explain this contract's purpose to someone's grandmother in 30 seconds?

**The 'Weekend Rebuild Test'**: Based on docs/design/implementation-roadmap.md, could a competent developer rebuild this from scratch in a weekend?

**The 'Audit Test'**: Based on docs/architecture/threat-model.md, would a security auditor immediately understand the attack surface?

**The 'User Test'**: Based on docs/architecture/contract-interfaces.md, can a typical user interact with this without reading documentation?

**The 'Gas Test'**: Based on docs/architecture/gas-optimization.md, are all functions under reasonable gas limits?

For each test that fails, provide specific simplification recommendations and update the relevant design documents.
```

---

## Integration Summary

This enhanced guide creates a complete design-to-development pipeline:

1. **Design Phase**: Structured discovery with immediate documentation
2. **Architecture Phase**: Collaborative refinement with cross-references
3. **Validation Phase**: Quality gates and KISS compliance
4. **Development Phase**: Your existing Solidity rules reference the design docs
5. **Cross-Validation**: Continuous checking that implementation matches design

The result is a bulletproof development process where design drives implementation, and both phases maintain KISS principles throughout.
