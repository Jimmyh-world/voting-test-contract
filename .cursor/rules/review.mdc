---
description: This guide helps AI assistants analyze existing smart contracts and develop comprehensive upgrade plans to bring them up to modern standards. It integrates with your design and development cursor rules to ensure consistent quality across your entire contract ecosystem
alwaysApply: false
---

# Smart Contract Upgrade & Modernization Guide

This guide helps AI assistants analyze existing smart contracts and develop comprehensive upgrade plans to bring them up to modern standards. It integrates with your design and development cursor rules to ensure consistent quality across your entire contract ecosystem.

## Project Structure Setup for Upgrades

**Cursor AI Instructions**: Before analyzing existing contracts, create this folder structure:

```
project/
├── contracts/              # Current contract source code
├── contracts-legacy/       # Backup of original contracts
├── docs/
│   ├── upgrade/           # Upgrade analysis and planning
│   │   ├── current-state-analysis.md
│   │   ├── gap-analysis.md
│   │   ├── upgrade-strategy.md
│   │   ├── implementation-plan.md
│   │   └── migration-plan.md
│   ├── design/            # New design docs (if major redesign needed)
│   └── architecture/      # New architecture docs (if major redesign needed)
├── scripts/
│   ├── analysis/          # Contract analysis scripts
│   └── migration/         # Data migration scripts
└── test/
    ├── legacy/            # Tests for existing contracts
    └── upgrade/           # Tests for upgrade scenarios
```

**Cursor Command**: Use this to auto-generate the structure:

```bash
mkdir -p contracts-legacy docs/upgrade scripts/{analysis,migration} test/{legacy,upgrade}
touch docs/upgrade/{current-state-analysis,gap-analysis,upgrade-strategy,implementation-plan,migration-plan}.md
```

## Phase 1: Current State Analysis

**Cursor AI Instructions**: Systematically analyze existing contracts and document findings. Reference your Solidity cursor rules standards throughout the analysis.

### A. Contract Discovery & Inventory

**File**: `docs/upgrade/current-state-analysis.md`

**Ask the upgrade planner:**

1. **What contracts are in scope for this upgrade?** (List all contracts, addresses, and purposes)

2. **What's the current deployment status?** (Mainnet, testnet, development versions)

3. **What are the critical dependencies?** (Other contracts, oracles, external integrations)

4. **What's the current user base and activity level?** (Transaction volume, value locked, active users)

5. **Are there any known issues or technical debt?** (Bugs, inefficiencies, security concerns)

**Cursor Action**: Create inventory in `docs/upgrade/current-state-analysis.md`:

```markdown
# Current State Analysis: [Project Name]

## Contract Inventory

| Contract   | Address   | Purpose   | LOC     | Last Updated | Status              |
| ---------- | --------- | --------- | ------- | ------------ | ------------------- |
| [Contract] | [Address] | [Purpose] | [Lines] | [Date]       | [Active/Deprecated] |

## Deployment Information

**Networks**: [List of networks and addresses]
**Verification Status**: [Verified/Unverified on block explorers]
**Proxy Pattern**: [Used/Not used, which type]
**Admin Controls**: [Who has admin access, what powers]

## Usage Statistics

**Daily Transactions**: [Average over last 30 days]
**Total Value Locked**: [Current TVL if applicable]
**Active Users**: [Unique addresses interacting]
**Peak Usage**: [Highest usage periods and triggers]

## Known Issues

**Security Concerns**: [Any known vulnerabilities]
**Performance Issues**: [Gas inefficiencies, bottlenecks]
**Technical Debt**: [Code quality issues, outdated patterns]
**User Complaints**: [Common user-reported issues]

## Integration Dependencies

**Upstream Dependencies**: [Contracts this depends on]
**Downstream Dependencies**: [Contracts/dApps that depend on this]
**External Integrations**: [Oracles, bridges, other protocols]
```

### B. Security & Code Quality Assessment

**File**: `docs/upgrade/gap-analysis.md`

**Cursor Prompt**:

```
Perform a comprehensive analysis of existing contracts against modern Solidity standards:

1. **Security Standards Compliance** (reference your Solidity cursor rules):
   - Check for CEI (Checks-Effects-Interactions) pattern violations
   - Identify reentrancy vulnerabilities
   - Assess access control implementations
   - Review external call safety
   - Analyze for common attack vectors (flash loans, MEV, oracle manipulation)

2. **Code Quality Assessment**:
   - Compare against KISS principles from design guide
   - Identify overly complex functions or contracts
   - Check for proper error handling (custom errors vs. revert strings)
   - Assess gas efficiency opportunities
   - Review documentation completeness

3. **Architecture Review**:
   - Evaluate single responsibility principle adherence
   - Check for proper separation of concerns
   - Assess upgradeability patterns (if any)
   - Review state management efficiency
   - Analyze external dependency management

Document findings in docs/upgrade/gap-analysis.md with specific code references and severity ratings.
```

**Cursor Action**: Generate comprehensive gap analysis:

```markdown
# Gap Analysis: [Project Name]

## Security Assessment

### Critical Issues (Immediate attention required)

| Issue   | Location        | Risk Level    | Impact           | Mitigation     |
| ------- | --------------- | ------------- | ---------------- | -------------- |
| [Issue] | [Contract:Line] | Critical/High | [Potential loss] | [Required fix] |

### Code Quality Issues

| Issue   | Location            | Severity     | Standards Violation | Recommended Fix |
| ------- | ------------------- | ------------ | ------------------- | --------------- |
| [Issue] | [Contract:Function] | High/Med/Low | [Which standard]    | [How to fix]    |

### KISS Compliance Review

**Complexity Score**: [Simple/Medium/Complex]

- **Functions per contract**: [Average, max - target ≤7 external functions]
- **Lines per function**: [Average, max - target ≤20 lines]
- **External dependencies**: [Count - minimize per KISS principles]
- **Admin functions**: [Count - minimize per security standards]

### Gas Efficiency Assessment

| Optimization Opportunity | Location            | Potential Savings | Implementation Effort |
| ------------------------ | ------------------- | ----------------- | --------------------- |
| [Opportunity]            | [Contract:Function] | [Gas amount]      | [Low/Med/High]        |

### Documentation Gaps

- **Missing NatSpec**: [List functions without proper documentation]
- **Architecture documentation**: [Present/Missing]
- **Security assumptions**: [Documented/Undocumented]
- **Integration guides**: [Available/Missing]

## Compliance Summary

**Overall Standards Compliance**: [X%]

- Security Standards: [X%]
- KISS Principles: [X%]
- Gas Efficiency: [X%]
- Documentation: [X%]

## Recommendations Priority

1. **Critical Security Fixes**: [List]
2. **Architecture Improvements**: [List]
3. **Gas Optimizations**: [List]
4. **Documentation Updates**: [List]
```

### C. User Impact & Risk Assessment

**File**: `docs/upgrade/upgrade-strategy.md`

**Ask the upgrade planner:**

1. **What would be the impact of downtime during upgrade?** (Financial impact, user experience)

2. **Are there critical integrations that cannot break?** (Partner dApps, other protocols)

3. **What's the tolerance for gas cost changes?** (User sensitivity to fee increases)

4. **Are there regulatory or compliance considerations?** (Legal requirements, audit needs)

5. **What's the preferred upgrade timeline?** (Urgent fixes vs. planned improvements)

**Cursor Action**: Document strategy in `docs/upgrade/upgrade-strategy.md`:

```markdown
# Upgrade Strategy: [Project Name]

## Risk Assessment

**Downtime Impact**: [High/Medium/Low]

- **Financial Impact**: [Estimated cost of downtime]
- **User Impact**: [Number of affected users, severity]
- **Reputation Risk**: [Community reaction, trust impact]

**Integration Risk**: [High/Medium/Low]

- **Critical Integrations**: [List partners that cannot break]
- **API Compatibility**: [Breaking changes required/not required]
- **Data Migration Risk**: [Complexity of state migration]

## Upgrade Approach Decision Matrix

### Option 1: In-Place Upgrade (Proxy Pattern)

**Feasibility**: [Possible/Not Possible - check if proxy exists]
**Pros**: [Seamless for users, preserves addresses]
**Cons**: [Storage layout constraints, proxy risks]
**Timeline**: [Estimated timeframe]

### Option 2: New Deployment + Migration

**Feasibility**: [Always possible]
**Pros**: [Clean slate, optimal architecture]
**Cons**: [User migration required, integration updates]
**Timeline**: [Estimated timeframe]

### Option 3: Gradual Migration

**Feasibility**: [Depends on architecture]
**Pros**: [Reduced risk, gradual transition]
**Cons**: [Complexity, longer timeline]
**Timeline**: [Estimated timeframe]

## Recommended Strategy

**Primary Approach**: [Selected option with rationale]
**Fallback Plan**: [Alternative if primary fails]
**Risk Mitigation**: [Specific measures to reduce risks]

## Stakeholder Communication Plan

**Internal Team**: [How to coordinate development]
**Users**: [Communication strategy and timeline]
**Partners**: [Integration partner notification process]
**Community**: [Public communication approach]
```

## Phase 2: Modernization Planning

**Cursor AI Instructions**: Based on gap analysis, create detailed modernization plans that align with your design and development standards.

### A. Architecture Modernization Design

**Files**: `docs/design/` and `docs/architecture/` (if major redesign needed)

**Cursor Prompt**:

```
Based on the gap analysis in docs/upgrade/gap-analysis.md, determine if a major architectural redesign is needed:

1. **Redesign Assessment**:
   - If complexity score is "Complex" or security issues are "Critical"
   - If more than 30% of functions need significant changes
   - If current architecture violates KISS principles extensively
   - Then: Use your design guide to create new architecture documents

2. **Design Process** (if redesign needed):
   - Use the discovery questions from your design guide
   - Apply KISS principles to simplify the current complex architecture
   - Create new technical-specification.md and architecture documents
   - Ensure backward compatibility requirements are addressed

3. **Incremental Improvement** (if redesign not needed):
   - Focus on targeted fixes for gap analysis findings
   - Maintain current architecture but apply modern standards
   - Document changes in upgrade-specific documents

Generate either full design documents or targeted improvement plans based on this assessment.
```

### B. Implementation Planning

**File**: `docs/upgrade/implementation-plan.md`

**Cursor Prompt**:

```
Create a detailed implementation plan based on gap analysis and upgrade strategy:

1. **Implementation Phases**:
   - **Phase 1: Critical Security Fixes** (must do immediately)
   - **Phase 2: Architecture Improvements** (structural changes)
   - **Phase 3: Gas Optimizations** (efficiency improvements)
   - **Phase 4: Documentation & Tooling** (supporting materials)

2. **For Each Phase**:
   - List specific changes from gap analysis
   - Estimate development time and complexity
   - Identify testing requirements
   - Plan deployment strategy
   - Define success criteria

3. **Cross-Reference Standards**:
   - Ensure all changes align with your Solidity cursor rules
   - Apply KISS principles to avoid over-engineering
   - Reference security standards for all fixes
   - Plan comprehensive testing per your testing standards

4. **Risk Management**:
   - Identify potential issues with each change
   - Plan rollback strategies
   - Define monitoring and alerting needs
   - Create emergency response procedures

Save detailed implementation roadmap to docs/upgrade/implementation-plan.md
```

**Implementation Plan Template**:

```markdown
# Implementation Plan: [Project Name]

## Phase 1: Critical Security Fixes (Timeline: [X weeks])

### Security Issues (from gap analysis)

| Issue   | Current Risk | Fix Description | Testing Required | Deployment Strategy |
| ------- | ------------ | --------------- | ---------------- | ------------------- |
| [Issue] | [Risk level] | [How to fix]    | [Test approach]  | [Deploy method]     |

### Success Criteria

- [ ] All critical security issues resolved
- [ ] Security audit passed (if applicable)
- [ ] No regression in existing functionality
- [ ] Gas costs remain within acceptable range

## Phase 2: Architecture Improvements (Timeline: [X weeks])

### Complexity Reduction (KISS compliance)

| Improvement | Current State     | Target State     | Implementation  | Impact        |
| ----------- | ----------------- | ---------------- | --------------- | ------------- |
| [Change]    | [Complex pattern] | [Simple pattern] | [How to change] | [User impact] |

### Modern Standards Application

- **Custom Errors**: Replace revert strings with custom errors
- **CEI Pattern**: Implement Checks-Effects-Interactions everywhere
- **Access Control**: Upgrade to role-based access (if needed)
- **State Management**: Optimize storage layout and usage

## Phase 3: Gas Optimizations (Timeline: [X weeks])

### Optimization Opportunities (from gap analysis)

| Optimization   | Current Gas | Target Gas | Implementation Effort | User Benefit |
| -------------- | ----------- | ---------- | --------------------- | ------------ |
| [Optimization] | [Current]   | [Target]   | [Effort level]        | [Savings]    |

## Phase 4: Documentation & Tooling (Timeline: [X weeks])

### Documentation Requirements

- [ ] Complete NatSpec for all functions
- [ ] Architecture documentation
- [ ] Integration guides
- [ ] Security documentation
- [ ] Deployment procedures

### Testing & Verification

- [ ] Unit test coverage >95%
- [ ] Integration tests for all external interactions
- [ ] Security test suite
- [ ] Gas benchmark tests
- [ ] Upgrade simulation tests

## Cross-Phase Requirements

### Standards Compliance Validation

- [ ] All changes follow Solidity cursor rules
- [ ] KISS principles maintained throughout
- [ ] Security standards applied consistently
- [ ] Documentation standards met

### Quality Gates

Each phase must pass these gates before proceeding:

- [ ] Code review by security-focused developer
- [ ] Automated testing with >95% coverage
- [ ] Gas consumption within target ranges
- [ ] No new security vulnerabilities introduced
- [ ] Documentation updated and reviewed

## Risk Management

### Rollback Procedures

**Phase 1**: [How to rollback security fixes if issues arise]
**Phase 2**: [How to rollback architecture changes]
**Phase 3**: [How to rollback optimizations]

### Monitoring & Alerting

**Key Metrics**: [What to monitor post-upgrade]
**Alert Thresholds**: [When to trigger alerts]
**Response Procedures**: [How to respond to issues]

## Resource Requirements

**Development Time**: [Total estimated hours]
**Testing Time**: [Testing and QA requirements]
**Audit Requirements**: [External audit needs]
**Deployment Resources**: [Gas costs, infrastructure needs]
```

### C. Migration & Data Handling

**File**: `docs/upgrade/migration-plan.md`

**Cursor Prompt**:

```
Create a comprehensive migration plan for users and data:

1. **Data Migration Analysis**:
   - Identify all state variables that need migration
   - Plan for data transformation if storage layout changes
   - Consider data that can be reconstructed from events
   - Plan for data that must be preserved vs. can be reset

2. **User Migration Strategy**:
   - Plan communication timeline and messaging
   - Create migration tools and interfaces
   - Design incentive mechanisms (if needed)
   - Plan support and troubleshooting resources

3. **Integration Partner Migration**:
   - Identify all external integrations
   - Plan API compatibility and breaking changes
   - Create migration guides and tools for partners
   - Schedule coordination meetings and testing

4. **Technical Migration Execution**:
   - Plan deployment sequence for multiple contracts
   - Design state migration scripts and verification
   - Plan testing in production-like environments
   - Create monitoring and rollback procedures

Document complete migration strategy with timelines and responsibilities.
```

## Phase 3: Implementation Execution

**Cursor AI Instructions**: Execute the implementation plan using your existing Solidity cursor rules with upgrade-specific considerations.

### A. Upgrade-Aware Development

**Enhanced Solidity Cursor Rules Integration**:

```
When implementing upgrades to existing contracts:

1. **Pre-Implementation Validation**:
   - Review docs/upgrade/gap-analysis.md for specific issues to address
   - Check docs/upgrade/implementation-plan.md for phase requirements
   - Verify that changes align with upgrade strategy
   - Ensure backward compatibility requirements are met

2. **Implementation Standards** (use existing Solidity cursor rules PLUS):
   - **Storage Compatibility**: If using proxy pattern, maintain storage layout
   - **Interface Stability**: Preserve existing function signatures unless breaking change is planned
   - **Migration Support**: Include functions to help users migrate if needed
   - **Gradual Rollout**: Design features to allow gradual activation if needed

3. **Upgrade-Specific Testing**:
   - Test migration scenarios with real data
   - Verify backward compatibility with existing integrations
   - Test upgrade mechanisms (proxy upgrades, migration tools)
   - Benchmark gas costs against current implementation

4. **Documentation Requirements**:
   - Document all breaking changes and migration requirements
   - Update integration guides for external partners
   - Create changelog with clear version differences
   - Provide migration examples and tools

Reference your standard Solidity cursor rules for all implementation details while adding these upgrade-specific considerations.
```

### B. Quality Assurance for Upgrades

**Cursor Prompt**:

```
Perform upgrade-specific quality assurance:

1. **Compatibility Testing**:
   - Test against existing user data and usage patterns
   - Verify all external integrations still work
   - Confirm gas costs are within acceptable ranges
   - Test edge cases specific to upgrade scenarios

2. **Migration Testing**:
   - Test data migration scripts with production data copies
   - Verify state transitions work correctly
   - Test rollback procedures work as designed
   - Confirm user migration tools function properly

3. **Performance Validation**:
   - Benchmark gas costs against original implementation
   - Test with realistic transaction volumes
   - Verify no performance regressions in critical paths
   - Confirm new features don't negatively impact existing functionality

4. **Security Validation**:
   - Confirm all issues from gap analysis are resolved
   - Verify no new vulnerabilities introduced
   - Test upgrade mechanisms for security issues
   - Validate access controls work in upgrade scenarios

Generate comprehensive test results and validation report.
```

## Phase 4: Deployment & Migration Execution

### A. Pre-Deployment Validation

**File**: `docs/upgrade/deployment-checklist.md`

**Cursor Prompt**:

```
Create a comprehensive pre-deployment checklist:

**Code Quality Validation**:
- [ ] All issues from gap analysis addressed
- [ ] Code follows updated Solidity cursor rules
- [ ] KISS principles maintained throughout changes
- [ ] Gas optimizations implemented as planned

**Testing Validation**:
- [ ] Unit test coverage >95%
- [ ] Integration tests pass with existing systems
- [ ] Migration scenarios tested thoroughly
- [ ] Performance benchmarks meet targets

**Documentation Validation**:
- [ ] All breaking changes documented
- [ ] Migration guides complete and tested
- [ ] Integration partner guides updated
- [ ] Emergency procedures documented

**Deployment Preparation**:
- [ ] Migration scripts tested on testnet
- [ ] Deployment scripts validated
- [ ] Rollback procedures tested
- [ ] Monitoring and alerting configured

Generate detailed checklist with verification steps for each item.
```

### B. Deployment Execution Strategy

**Cursor Prompt**:

```
Execute deployment based on upgrade strategy selected:

**For Proxy Upgrades**:
1. Deploy new implementation contract
2. Test implementation thoroughly on testnet
3. Execute upgrade transaction with proper testing
4. Verify upgrade worked correctly
5. Monitor for issues and user feedback

**For New Deployment + Migration**:
1. Deploy new contracts with migration support
2. Deploy migration tools and interfaces
3. Begin user communication and migration incentives
4. Monitor migration progress and provide support
5. Plan deprecation of old contracts

**For Gradual Migration**:
1. Deploy new contracts alongside existing ones
2. Implement bridging or forwarding mechanisms
3. Gradually migrate users and liquidity
4. Monitor both systems during transition
5. Complete migration and deprecate old system

Include specific commands, transaction sequences, and verification steps for chosen strategy.
```

## Phase 5: Post-Upgrade Monitoring & Validation

### A. Post-Deployment Monitoring

**Cursor Prompt**:

```
Implement comprehensive post-upgrade monitoring:

1. **Technical Monitoring**:
   - Track gas consumption vs. pre-upgrade baseline
   - Monitor transaction success rates
   - Track any new error patterns or failures
   - Monitor performance of new features

2. **User Experience Monitoring**:
   - Track user adoption of new features
   - Monitor migration completion rates
   - Track user support requests and issues
   - Monitor user feedback and sentiment

3. **Integration Monitoring**:
   - Verify external integrations working correctly
   - Track partner adoption of new features
   - Monitor for integration-related issues
   - Validate API compatibility maintained

4. **Security Monitoring**:
   - Watch for exploitation attempts on fixed vulnerabilities
   - Monitor for new attack vectors
   - Track admin function usage
   - Monitor for unusual transaction patterns

Create monitoring dashboard and alert configuration.
```

### B. Success Validation & Reporting

**File**: `docs/upgrade/upgrade-completion-report.md`

**Cursor Prompt**:

```
Generate a comprehensive upgrade completion report:

**Upgrade Success Metrics**:
- All critical security issues resolved: [✓/✗]
- KISS compliance improved: [Before/After score]
- Gas efficiency improved: [% improvement]
- User migration completed: [% migrated]
- Integration partners updated: [% completed]

**Performance Comparison**:
| Metric | Pre-Upgrade | Post-Upgrade | Change |
|--------|-------------|--------------|--------|
| Gas Cost | [Amount] | [Amount] | [% change] |
| Transaction Success Rate | [%] | [%] | [% change] |
| User Satisfaction | [Score] | [Score] | [Change] |

**Standards Compliance Achievement**:
- Security Standards: [Compliance %]
- KISS Principles: [Compliance %]
- Documentation Standards: [Compliance %]
- Testing Standards: [Compliance %]

**Lessons Learned**:
- What went well during upgrade
- What could be improved for future upgrades
- Recommendations for ongoing maintenance
- Updates needed for upgrade processes

**Future Maintenance Plan**:
- Regular review schedule
- Monitoring and alerting maintenance
- Documentation update procedures
- User support and feedback collection

Save complete report with recommendations for future upgrades.
```

---

## Integration with Design & Development Workflow

### A. Cross-Reference Integration

**Design Phase Integration**:

- When gap analysis reveals major architectural issues, use your design guide to redesign
- Apply KISS principles to simplify overly complex existing contracts
- Use threat modeling from design guide to address security gaps

**Development Phase Integration**:

- Use your Solidity cursor rules for all implementation work
- Add upgrade-specific requirements to standard development process
- Maintain same quality standards for upgraded contracts

**Continuous Improvement**:

- Regular audits using this upgrade guide
- Proactive modernization before issues become critical
- Integration with development lifecycle for ongoing maintenance

### B. Quality Gates Integration

**Before Any Upgrade Project**:

- [ ] Gap analysis completed and reviewed
- [ ] Upgrade strategy selected and approved
- [ ] Implementation plan detailed and resourced
- [ ] Migration plan tested and validated

**During Implementation**:

- [ ] Each phase passes quality gates
- [ ] Standards compliance maintained
- [ ] Testing requirements met
- [ ] Documentation updated continuously

**After Upgrade**:

- [ ] Success metrics achieved
- [ ] User migration completed successfully
- [ ] Integration partners updated
- [ ] Monitoring and maintenance plan active

---

## AI Assistant Guidelines for Upgrades

### Always Advocate for Simplification

- Use upgrades as opportunities to simplify complex contracts
- Question whether all existing features are still needed
- Apply KISS principles more rigorously than original implementation
- Consider breaking complex contracts into simpler, focused ones

### Security-First Upgrade Approach

- Prioritize security fixes over feature additions
- Assume existing contracts have unknown vulnerabilities
- Design upgrades to be more secure than originals
- Plan for security issues discovered during upgrade process

### User-Centric Migration Planning

- Minimize user friction and confusion during upgrades
- Provide clear communication and migration tools
- Plan for user mistakes and provide recovery mechanisms
- Monitor user experience throughout upgrade process

### Integration-Aware Development

- Consider impact on all existing integrations
- Provide migration tools and guides for partners
- Plan backward compatibility carefully
- Coordinate with ecosystem partners throughout process

---

_This upgrade guide ensures systematic modernization of existing contracts while maintaining the same high standards applied to new development. It integrates seamlessly with your design and development cursor rules to provide a complete contract lifecycle management system._
